% Beamforming simulation from measured far-field patterns
% Adaptado al formato de archivo ant1.txt, ant2.txt, etc.

clear; clc;

%% Configuraci√≥n
freq_target = 5.8e9;                    % Frecuencia deseada [Hz]
c = 3e8;
lambda = c / freq_target;
d = lambda / 2;                         % Separaci√≥n entre antenas (m)

N = 4;                                  % N√∫mero de antenas transmisoras
positions = [0:d:(N-1)*d; 0 0 0 0; 0 0 0 0]; % Alineadas en X

% Fases relativas en grados (puedes modificarlas)
phases_deg = [0 -90 -180 -270];
phases_rad = deg2rad(phases_deg);

% Archivos de far-field individuales
files = {
    'ant1.txt',
    'ant2.txt',
    'ant3.txt',
    'ant4.txt'
};

% Inicializaci√≥n de estructuras
theta_all = [];
phi_all = [];

% Inicializar campo total
E_total = [];

for i = 1:N
    % Leer datos y filtrar por frecuencia
    data = readmatrix(files{i}, 'NumHeaderLines', 1);
    data_5800 = data(data(:,3) == freq_target, :);

    az = data_5800(:,1);                % Azimuth (phi)
    el = data_5800(:,2);                % Elevation (theta)
    phi = az; theta = el;
    
    % Guardar rejilla angular (solo en primera iteraci√≥n)
    if i == 1
        phi_unique = unique(phi);
        theta_unique = unique(theta);
        [Phi, Theta] = meshgrid(phi_unique, theta_unique);
        E_total = zeros(size(Phi));
    end

    % Crear mapa de Etheta (usamos EH = componente H)
    EH_re = data_5800(:,4);
    EH_im = data_5800(:,5);
    Eth = EH_re + 1i * EH_im;

    % Reorganizar a matriz 2D
    Eth_matrix = reshape(Eth, length(theta_unique), length(phi_unique));

    % Factor de fase de posici√≥n y excitaci√≥n
    k = 2 * pi / lambda;
    r = positions(:,i);
    phase_shift = exp(1i * (k * (r(1)*sin(Theta).*cos(Phi) + ...
                                 r(2)*sin(Theta).*sin(Phi) + ...
                                 r(3)*cos(Theta)) + phases_rad(i)));

    % Sumar al campo total
    E_total = E_total + Eth_matrix .* phase_shift;
end



%% Visualizaci√≥n 3D del patr√≥n
E_mag = abs(E_total);
E_mag_norm = E_mag / max(E_mag(:));
R = E_mag_norm;

%% Visualizaci√≥n 3D del patr√≥n (NO NORMALIZADO)
R = E_mag;  % Usar campo el√©ctrico real sin normalizar
[X,Y,Z] = sph2cart(Phi, pi/2 - Theta, R);

figure;
surf(X, Y, Z, R, 'EdgeColor', 'none');
axis equal;
xlabel('X'); ylabel('Y'); zlabel('Z');
title('Patr√≥n de radiaci√≥n combinado - Beamforming (5.8 GHz, sin normalizar)');
colorbar;
view(30,30);
lighting gouraud
camlight headlight


%% C√°lculo del campo y ganancia m√°ximos
[max_E, idx_max] = max(E_mag(:));
[max_row, max_col] = ind2sub(size(E_mag), idx_max);
theta_max = theta_unique(max_row);
phi_max = phi_unique(max_col);

gain_max_dB = 10 * log10(max_E.^2);  % Offset puede a√±adirse si se calibra

fprintf('‚ö° M√°ximo |E| = %.4f (no normalizado)\n', max_E);
fprintf('‚Ü™ En direcci√≥n: Œ∏ = %.2f¬∞, œÜ = %.2f¬∞\n', theta_max, phi_max);
fprintf('üì° Ganancia m√°xima (relativa): %.2f dB\n', gain_max_dB);

%% Visualizaci√≥n 3D del patr√≥n en dB (con umbral)

E_dB = 20*log10(E_mag);                  % Convertir a dB
E_dB(~isfinite(E_dB)) = -100;           % Evitar -Inf o NaN
threshold_dB = -30;                     % Umbral visual
E_dB_clipped = max(E_dB, threshold_dB); % Aplicar umbral

R_db = E_dB_clipped;                    % Usar dB como radio
[Xdb, Ydb, Zdb] = sph2cart(Phi, pi/2 - Theta, R_db);

figure;
surf(Xdb, Ydb, Zdb, R_db, 'EdgeColor', 'none');
axis equal;
xlabel('X'); ylabel('Y'); zlabel('Z');
title(sprintf('Patr√≥n de radiaci√≥n (dB, umbral = %d dB)', threshold_dB));
colorbar;
view(30,30);
lighting gouraud
camlight headlight
caxis([threshold_dB max(R_db(:))]);



